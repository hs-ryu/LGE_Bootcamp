# Review

- 정의 : SW 품질을 보장하기 위해 SW 개발 동안 생성되는 코드 뿐만 아니라 관련 산출물들의 잠재적인 결함(Defect)을 찾아내고 이를 개선하는 일련의 과정.
- 다양한 관점에서 리뷰가 이루어지지 않으면 잠재 결함들을 효율적으로 찾기 어려움
- Static Analysis, Peer Review 방식을 적용하여 가능한 많은 잠재 결함을 찾고 해결



### Peer Review

- 효과
  - 눈덩이 효과 : 결함을 발견하는 시점이 개발 후반부로 갈 수록 결함 수정 비용은 기하급수적으로 증가
  - 결함 조기 발견으로 결함 수정 비용 절감
  - 개발자 및 동료들간의 기술 공유
  - 팀워크 및 조직 역량(전문성) 향상
  - 제품 및 도메인에 대한 지식의 향상
  - 프로젝트 관리자의 제품 품질 조기 파악 및 조치 가능
  - 관리자에게 제품 품질에 대한 통찰력(insight) 제시
  - 개발 산출물 및 코드의 판독성이 향상되고 유지보수 용이
  - 제품의 품질과 생산성 향상
  - 기술적 정보(Technical information)에 대한 의사소통의 기회 제공

- 가능한 산출물
  - 프로젝트 관리 계획서
  - 요구사항 명세서
  - 상위 설계서
  - 상세설계서
  - 소스 코드
  - 테스트 계획서 및 테스트 절차
  - 사용자 문서 및 도움말 화면
  - 시스템 유지보수 문서
  - 프로세스 정의서, 프로시저, 양식(템플릿)

- Peer Review 대상 선정 방법
  - High-risk 작업 산출물에 Peer Review 노력을 집중하도록 함
  - 새로운 기술 또는 기법 적용된 산출물
  - 복잡한 로직 또는 알고리즘의 산출물
  - Failure mode가 많은 산출물
  - 경험이 부족한 작업자가 생성한 산출물

- Peer Review에 임하는 자세
  1. 당신이 실수할 수 있다는 것을 받아들이라.
  2. 당신의 코드는 당신의 작품이 아니다.
  3. 장기도 훈수 두는 사람이 더 잘 안다.
  4. 조언 없이 코드를 다시 쓰지 마라.
  5. 잘 알지 못하는 사람들을 존경하고, 인내하라.
  6. 세상에서 변하지 않는 진리는 변한다는 것이다.
  7. 진정한 권위는 직위가 아닌 지식으로부터 나온다.
  8. 당신이 알고 있는 지식을 고수하며 싸워라. 그러나 패배는 겸허히 받아들이라.
  9. 독방의 개발자는 되지 마라.
  10. 사람이 아닌 코드를 비판하고, 코드가 아닌 사람에게 친절하라.

- 실행 방안
  - 한번의 Review시 200~400 LOC 이하의 code를 리뷰
  - 300~500 LOC/Hour 의 속도로 진행
  - 한번의 리뷰는 60~90분 정도로
  - 발견된 Defect들은 Tracking하여 관리하고, 리워크를 통해 반드시 수정한다.
  - 개발자들의 힘만으로는 힘들다 - 회사 차원에서 정채적으로 추진

- peer review 종류
  - Over the shoulder review
    - Author가 자신의 code를 자신의 자리에서 직접 보여주며 설명
    - 실행하기 용이하고 완료가 빠름.
    - 실제 결함이 수정되었는지 검증이 어려움
    - 아무런 측정, 개선 활동이 포함되어 있지 않음.
  - Pass-Around review
    - Offline or E-mail로 돌려보기
    - Review를 받고 싶은 부분을 알리고 통지를 받은 사람들은 자신의 의견을 전달한다.
    - Reviewer는 자신의 의견을 코맨트
  - Walkthrough Review
    - Author가 code를 가지고 논의를 이끈다.
    - 팀원들로부터 자유롭게 의견을 수렴한다.
    - 단체로 진행되는 Review 활동 중 가장 인포머한 리뷰
    - Bug 수평전개와 같은 공유 성격
    - Preparation이 필요 없다.
- inspection 참가자 역할









## Code Review

### 중점적으로 볼 항목

1. Function
2. indentation
3. variable
4. 전체적인 가독성

- 전체적으로 연산자 사이의 인덴테이션이 자기멋대로다. 띄어쓰기 등
- 한줄 주석에서도 /**/ 을 사용하는 경우

### calendar.c

```c
/** **/   ->  /* */ 로 하는게 맞을듯.
    
#include "libcalendar.h" -> 헤더 파일 이름 확인 필요.   
 
main()   ->   void main()
    

```



### calendar.h

```c
calendar.h -> 파일 이름 수정
    
#define TRUE 1 -> 굳이 TRUE, FALSE를 대문자로 써야하는가? 아니면 명시해야할 필요가 있는가? -> 유지

```



### libcalendar.c

```c
int get_year(void) {}
// 유저가 입력한 값에 대한 유효성 검증 로직 필요
// 1. printf() 구문에서 숫자만 입력하라는 문구 추가.
// 2. 반복문을 통해 연도 입력 받을때 까지 진행.
// 3. 혹은 에러처리를 통해 숫자 입력을 하라고 하는 문구 출력.

int get_day_code(int year) {}
// x1,x2,x3를 굳이 float으로 나눌 필요가 없다. 모두 int 타입으로 정의 되어있기 때문
// x1,x2,x3 변수명이 명확하지 않음. 변수명을 직관적으로 수정하고, 주석이 필요해 보임.
// 함수 자체에 가독성이 부족하다는 생각.

int get_leap_year(int year) {}
// 첫째줄 주석 삭제하거나 필요한 히스토리라면 추가 주석 필요

void print_calender(FILE ~~) {}
// 함수명과 내부 로직 사이에서의 괴리감. print_calender라는 이름과 다르게 함수 내부에서 계산하는 로직이 많이 들어감. 계산하는 부분을 따로 함수로 빼던가 함수 이름을 바꿔야함.
// int days_in_month ~~ 부분에서, 선언이 끝나기도 전에 주석을 처리하는 경우.
// fprintf (fount, "          %d", year); 에서, 간격을 주는 방법에서 수정 필요.

// for (month = 1; ~~~) {} switch - case 부분을 꼭 길게 적어야할까? 배열로 처리하는 방법도 있을듯. 이걸 유지하는게 좋은가 배열로 사용하는게 좋은가. 또한 default가 필요하지 않나?

// 공백 출력에 대한 부분

```





# Static Analysis

















# Software Test

- Static Testing

  - 프로그램을 실행하지 않고 결함을 찾아내는 것

  - 소프트웨어 개발 중 생성되는 모든 산출물에 적용 가능

- Dynamic Testing

  - 프로그램을 실행하여 결함을 찾아내는 것

  - 발견된 결함은 디버깅하여 수정

- Software Test  VS Software Debuggin
  - Test : Defect를 발견하는 과정
  - Debuging : Defect를 제거하는 과정



### 테스트 레벨

#### Unit Test

- 함수 단위의 테스트
- 프로그램을 기능별 유닛으로 나누고 특정 기능을 분리시켜 유닛이 의도된 대로 정확히 동작하는지 확인하는 절차
- 단위테스트는 개발 시간을 증가시키는 것이 아니라 디버깅 시간을 단축하기 위한 활동
- 단위 테스트 수행 환경의 구축
  - 단위 테스트 수행을 위해서는 테스트 항목을 독립적으로 실행시킬 수 있는 환경 구성이 필요
  - Test Driver : 테스트 대상 모듈을 호출하는 모의 모듈
  - Test Stub : 테스트 대상 모듈이 호출하는 모듈 대신에 만들어지는 Sub Routine
- 단위 테스트의 장점
  - 개발 후반부에 발생하는 결함 감소
  - 결함의 원인 분석이 용이
  - 소스 레벨에서 확인 가능
- 단위 테스트의 단점
  - 많은 노력을 해야함
  - 레거시 코드의 부담이 큼
  - 모든 버그를 찾아낼 수는 없음.

#### Integration Test

- 단위 테스트가 완료된 Unit들을 통합하여 테스트
- 가장 상위 모듈부터 하위 모듈로 점진적으로 통합
- 많은 수의 Stub 필요

#### System Test



## Test Technique

### Equivalence Partitioning

- 정의 : 입력 데이터를 유사한 특징을 가진 class로 분류하여 각 class에서 대표 Test Case를 도출하는 방법
- 특징 : 
  - 동일한 입력에 대해서는 항상 동일한 결과를 가져오도록 class를 구분함
  - 일반적으로 유효한 입력조건을 대표하는 Valid Class와 그 외의 다른 경우를 대표하는 Invalid Class로 구분

| 입력 조건이 범위를 나타낼 때   | 1개의 Valid EC / 2개의 Invalid EC     |
| ------------------------------ | ------------------------------------- |
| **입력 조건이 특정한 값일 떄** | **1개의 Valid EC / 2개의 Invalid EC** |
| **입력 조건이 집합일 때**      | **1개의 Valid EC / 1개의 Invalid EC** |
| **입력 값이 Boolean 값일 때**  | **1개의 Valid EC / 1개의 Invalid EC** |

### Boundary Value Analysis