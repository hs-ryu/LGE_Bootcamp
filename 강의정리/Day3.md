# 11/20 수업 정리

- 내가 생각한 솔루션이 연산이 몇번 이루어 질 것 인가? 를 확인해라
- Top - Down 방식으로 문제 해결 방식을 생각해 나가라!
- 큰 단위에서 문제 해결 방식을 생각하고 그 이후에 세부적으로 고민해봐라.
- 만약 해결해야할 문제에서 조금 더 깊게 아는 지식들이 있었을 때, 프로그램은 더 좋은 방식으로 발전할 수도 있다. (Ex. 숫자근 문제에서, 숫자근을 구하는 공식)

<br>

## 연습 문제 1 (폭탄 돌리기)

- 0 ~ 210 까지의 반복문을 통해 퀴즈를 푸는 시간을 확인하며 풀 거나, N까지의 반복문을 통해 퀴즈하나하나 걸리는 시간을 확인하면서 풀 수 있다.
- 어떤 방법을 채택하던지 간에 많은 연산을 필요로 하지 않는다.
- 퀴즈를 푸는 시간 T를 카운트 하고, 210초와 비교하여 확인해 나가면 됨.

<br>

## 연습 문제 2 (숫자근)

- 각각의 숫자의 최대 크기는 1,000,000
- 그 숫자의 숫자근을 구하기 위해 필요한 최대 연산은 999,999 -> 54 -> 9 로 별로 연산 안함.
- 따라서 각 숫자를 보면서 숫자근을 구해 나가도 연산이 많지 않다.
- 각 숫자는 몫, 나머지 연산을 통해 숫자근을 구해 나갈 수 있다.

### 또 다른 해법

- 숫자근을 바로 계산할 수 있는 공식이 있음
  - n = 0일 때 숫자근은 0
  - n != 0일 때 n을 b - 1로 나눈 나머지가 0이면 숫자근은 (b-1)
  - n != 0일 때 n 을 b - 1로 나눈 나머지가 0이 아니면 숫자근은 (n % b-1)

<br>

## 실전 미션 1 (순환 순열)

- 처음 출력하는 숫자 : N
- 그 이후 : N을 곱하고 P로 나눈 나머지
- 위 과정을 계속해서 나가면 순환되는 부분 발생
- 순환되는 부분 숫자의 개수를 출력

```
ex1)
N = 9, P = 3
1. 9
2. 9 * 9 % 3 -> 0
3. 0 * 9 % 3 -> 0
// 출력 : 1

ex2)
N = 67, P = 31
1. 67
2. 67 * 67 % 31 = 25
3. 25 * 67 % 31 = 1
4. 1 * 67 % 31 = 5
5. 5 * 67 % 31 = 25
// 출력 : 3

풀이 방법 :
0. N 부터 시작. 단, 첫번째 단계는 N을 출력하는 것이므로 visited[N]을 1로 만든 후 실행.
1. 순환 확인을 위한 visited 배열을 생성. 배열 크기는 1000.
2. 처음부터 단계를 밟아가면서, 방문 체크를 하고. 2번 방문한 놈들만 출력한다.
3. 끝!

풀이 방법 검증 :
0. 연산이 얼마나 이루어 질까?
- N = 1000 이고, P = 97일때. 1000 * 1000 % 97 -> 27
- 27 * 1000 % 97 -> 34
- 34 * 1000 % 97 -> 50
- 50 * 1000 % 97 -> 45
- 45 * 1000 % 97 -> 89
...
- 어차피 나머지를 사용하여 연산하기 때문에 1 ~ 97(P)까지 최대 97(P)번 반복할 것이라고 생각할 수 있음.
따라서 위 로직으로 진행해도 문제될 부분 없을 것!
```

<br>

## 실전 미션 2 (행복한 수)

- 행복한 수 : 각 자리수의 제곱의 합을 구해 나가는 과정을 연속적으로 적용하였을 때, 1까지 도달하는 수
- n에 대해, n0, n1, n2...의 수열을 정의한다면. n0 = n, n(i + 1)은 ni의 모든 자리수의 제곱의 합. 
- 만약 위 수열에서 ni = 1인 경우 n은 행복한 수이다. n이 행복한 수이면 수열의 모든 ni는 행복한 수

```
ex1)
n = 7
7 ^ 2 = 49
4 ^ 2 + 9 ^ 2 = 97
9 ^ 2 + 7 ^ 2 = 130
1 ^ 2 + 3 ^ 2 + 0 ^ 2 = 10
1 ^ 2 + 0 ^ 2 = 1
이기 때문에
7, 49, 97, 130, 10, 1의 수열이 발생한다.
여기서 n5 -> 1이기 때문에 7은 행복한 수이다. (또한 49, 97, 130, 10, 1은 모두 행복한 수이다)

풀이 :
ni = 1이 나오게 하기 위해선
n(i-1)이 1, 10, 100, 1000 중 하나여야한다.
다시 생각해보면 제곱수가 1, 10, 100, 1000이 나오는 경우는 아래와 같다.
1 ^ 2 = 1 (이건 의미 없음.)
1 ^ 2 + 3 ^ 2 = 10 혹은 3 ^ 2 + 1 ^ 2 = 10 (31과 13, 103과 130과 310)
가장 쉽게 생각할 수 있는 방법은 visited 배열을 하나 선언해서, 순환이 발생하는데 결과값으로 1이 나오지 않는다면 그 수는 행복한 수가 아니다.
0. 반복문을 사용해서 N부터 1까지 확인한다.
1. visited 배열을 만들어서, 순환이 발생하는지 확인한다. 순환 발생 시 결과값이 1이 나온다면 그 즉시 break후 결과값에 저장
2. 순환이 발생 안한다면? 다음 숫자 확인으로 넘어감.

풀이 방법 검증 : 
0. 연산이 얼마나 이루어 질까?
- N의 최대값은 1000. n = 999를 가지고 수열을 만들어 보면
n = 999
9 ^ 2 + 9 ^ 2 + 9 ^ 2 = 243
2 ^ 2 + 4 ^ 2 + 3 ^ 2 = 29
2 ^ 2 + 9 ^ 2 = 85
8 ^ 2 + 5 ^ 2 = 89
8 ^ 2 + 9 ^ 2 = ....
하지만, 주어진 정수보다 작거나 같은 정수 중에서 최대의 행복한 수를 구하라면? -> 최대 900개의 수를 봐야함. 900 * 1000 -> 900,000 으로 괜찮을듯함.
```





