# 11/22 수업 정리

## 11/22 피어 리뷰

### B5_서투른암소

### 강희재

- 올바른 괄호를 Check하는 알고리즘에서 stack을 이용하도록 구현하였는데, stack에 실제 값을 넣을 필요 없이 stack pointer(=sp)만 잘 설정하면 되기 때문에 실제 stack과는 조금 다르게 구현하였습니다.
- 주어진 문자열을 for문으로 돌면서 앞에서부터 check하다가 올바르지 않은 괄호가 나오면 바로 수정.
-  모든 문자열을 check했는데도 올바르지 않은 괄호일 경우 (가 더 많게되고 항상 짝수로 나오기 때문에 sp/2만큼을 더하는 방식으로 해결하였습니다.

### 류현선

- 스택. 여는 괄호면 스택에 넣고, 닫는 괄호면 스택에서 빼서 확인한다.
- 닫는 괄호가 나왔는데 여는 괄호가 스택에 없다? 그럼 하나는 무조건 바꿔서 넣어야함.
- 마지막에 스택을 확인해서, 여는 괄호가 남아있다면? 그 중에서 최소 절반은 바꿔야한다는 소리

### 김민정

- weight변수를 만들어 '(' 일 때 +1, ')' 일 때 -1 해줌.
- weight변수가 음수가 될 때 마다 -1을 곱해주고(보정), 보정 횟수를 카운트
- 총 weight 변수가 양수이면 열린 괄호가 많아진 것이므로, 그 중 반만 바꾸면 되니 weight/2
- 최종 값으로 weight/2 + 보정횟수 리턴

### B6_색종이(중)

### 강희재

- 주요 알고리즘이 2개라고 생각을 하고 풀었습니다.
- 2차원 배열에 검은 색종이가 몇 개 있는지 check하는 함수 : make_box
- 2차원 배열을 가지고 둘레를 재는 함수 둘레 = 경계(A와 B)라는 점을 이용해서 구현하였고 검은색종이가 있는 부분을 기준으로 상하좌우에 검은색종이가 아닌 경우에 count를 더하는 방식으로 진행

### 류현선

- 지도를 그린다
- 지도를 그리면서 영역에 visited 표시를 해놓고
- 비어있는 영역(0)에서 BFS
- 그리고 만약 0이 아닌것을 마주친다면 테두리일 것이므로 +1

### 김민정

- 색종이 붙인 영역을 모두 1, 나머지는 0
- 1 한칸은 1x1 정사각형이므로, 1의 상,하,좌,우 좌표가 0인 경우 테두리로 카운트

<br>

## 문제풀이

- 그리디한 문제의 특징
  - Optimal substructure 구조인가? 즉, 이전에 판단했던 선택이 이후 선택에 관여하는가?
    - DP를 활용한 문제들도 Optimal substructure이다.
  - Greedy Choice Property를 가지고 있는가? 최고의 선택이라고 생각했던 판단들이 나중에는 사용하면 안돼! 라는것...? 이게 뭔말이고?



## 연습문제 1 (회의실 배정)

- 회의 시작 시간, 종료시간
- 같은 시간대에 속하는 회의 -> 하나만 개최
- 종료시간 = 시작시간 -> 겹치는 것 아님.
- 회의의 개수 : 5 <= N <= 500
- 각 회의의 시작시간, 종료시간은 500 이하의 정수
- 회의를 최대한 많이 배정

```
# 접근
1. 정렬 먼저 근데 뭘? 시작 시간 기준.
2. 정렬 해서 카운트를 해보자.
3. 카운트 해서 제일 적게 카운트 된 애들을 채택한다.
```





## 연습문제 2 ()











