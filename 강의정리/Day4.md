# 11/21 수업 정리

## 11/21 피어 리뷰

### A3_순환순열

#### 김민정

- 중복되는 수가 나온 시점부터 순환이 시작된다.
- 이 때 순환이 시작된 연산 순서 - 처음 중복되는 수가 나왔던 연산 순서 = 순열 원소
- 이걸 그대로 Solution함수로 구현했다.

#### 강희재

- 계산을 거듭하며 A[i] 배열에 수를 저장하고, find()를 통해서 계산한 값이 이미 배열에 존재하는지 확인하는 방식으로 진행함.

- 계산되는 숫자들을 배열에다가 넣어감. 이후 배열에 그 수가 이미 존재하는지 확인
- cal()라는 함수에서 배열 A[]에 계산한 값들이 차례대로 저장하고, 순환되는 부분의 start, end 인덱스를 찾아내어 출력하는 방식.
- 처음에, 어렵게 생각해서 순환 순열이 발생하는 값을 출력해야 하는줄 알고 인덱스를 찾는 로직으로 작성했다.

#### 류현선

- 순환 확인을 위한 visited 배열을 생성. 배열 크기는 1000.
- N 부터 시작. 단, 첫번째 단계는 N을 출력하는 것이므로 visited[N]을 1로 만든 후 실행.
- 처음부터 단계를 밟아가면서, 방문 체크를 하고. 2번 방문한 숫자들의 개수를 출력한다.
- 위 로직을 구현하는데 연산이 얼마나 이루어 질까 생각해보면, 어차피 나머지를 사용하여 연산하기 때문에 1 ~ 97(P)까지 최대 97(P)번 반복할 것이라고 생각할 수 있음. 따라서 위 로직으로 진행해도 문제될 부분 없을 것이라 판단함.

<br>

### A4_행복한 수

#### 김민정

- 각 자릿수의 제곱을 더했을 때 한자릿수가 나오는 경우, 행복하지 않은 수는 절대 1에 도달하지 않음 (오히려 행복하지 않은 수는 한자릿수 나온 이후 또 증가함)
- 그럼 각 자릿수의 제곱합이 한자릿수가 될 떄 까지 더한 후,
- 1이 나오면 행복한 수, 그렇지 않으면 행복하지 않은 수로 분류하도록 구현

#### 강희재

- happy하지 않은 숫자를 판단하는게 중요하다고 생각했는데, happy의 경우에는 게산된 값이 1일 경우에 빠져나가도록 구현하였고,
- 반대로 unhappy의 경우에는 1이 나오지 않은 상태에서 순환을 돌기 시작하면 이 수는 unhappy한 수이다라걸 핵심 로직으로 생각하여 구현함.

#### 류현선

- 가장 쉽게 생각할 수 있는 방법은 visited 배열을 하나 선언해서, 순환이 발생하는데 결과값으로 1이 나오지 않는다면 그 수는 행복한 수가 아니다.
- 반복문을 사용해서 N부터 1까지 확인한다.
- visited 배열을 만들어서, 순환이 발생하는지 확인한다. 순환 발생 시 결과값이 1이 나온다면 그 즉시 break후 결과값에 저장
- 순환이 발생 안한다면? 다음 숫자 확인으로 넘어감.
- 위 로직을 구현하는데 연산이 얼마나 이루어 질까 생각해보면, n = 999 일때 9 ^ 2 + 9 ^ 2 + 9 ^ 2 = 243 이므로 최대 243번의 연산이 이루어 질 것. 또한 최대 1000개의 숫자를 반복문을 통해 볼 것이기 때문에 충분하다고 판단.

<br>

## 문제풀이

- int 타입 배열을 선언한 후 초기화 하지 않으면 0으로 초기화 된다.
- 요소의 개수(배열의 크기)는 컴파일 타임에 결정되어 있어야한다. 즉, 메모리 사이즈가 미리 결정되어야 한다는 소리
- 또한 초기화 되지 않은 전역변수를 접근하려고 하면 런타임 에러가 발생할 수 있다.
- 배열 크기를 만들때, 내가 얼마의 크기가 필요한지 알고 만드는게 좋다.

```c
int i;
for (i = 0; i < N; i++) {}	// 맞는 방법
for (int j = 0; j < N; j++) {}	// C++ 방식

// 만약 내가 어떤 컴파일러에서든 문제없이 이식성 좋은 코드를 작성하고 싶다면 위 방식을 채택하는 것이 좋다.
```

- main 안에서 다 때려박는 코드는 지양해라
- 가독성을 높이는게 코드를 잘 만드는 것에 유리하다.



## 연습 문제 1 (빙고)

- 25개 칸
- 상하좌우대각선 긋기
- 3줄 발생 시 빙고!!

- 최적화 할 수 있는 방법은?
  - 숫자 탐색 : 좌표를 저장하여 최초 한번 이후부터는 숫자 확인을 여러번 할 필요가 없다.
  - 빙고 줄 확인 : 숫자의 좌표를 안다면, 해당 숫자 좌표에서 행, 열 (가능하다면 대각선) 까지 확인하여 줄이 완성되었는지 판단한다. 줄 완성 시 카운트
  - 빙고 줄 확인2 : 줄 완성 판단을 행, 열, 대각선 방향의 개수 카운트를 한 이후, 카운트가 5가 된다면 빙고 줄 완성으로 판단한다.
- 의미 없이 반복하고 있는 행동들.



## 연습 문제 2 (빌딩)

- 각 자리수를 배열에 담는다.
- 각 자리수에서 나올 수 있는 범위는 0~9. 그 중 4는 제외된다. 따라서 총 9가지이다.
- 주어지는 숫자 N에 대해서, 각 자리수의 숫자에 9 ^ m 을 곱해준다. 즉 1의 자리라면 9 ^ 0 = 1을 곱해주는 것이다.
- 반복문을 돌면서 해당 값들을 더해준다.
- 더해 준 값을 출력한다.



## 실전 문제 1 (연속부분최대곱)

- 양의 실수 개수 : N <= 10000
- 조건 : 소수점 이하 넷째 자리에서 반올림하여 소수점 이하 셋째 자리까지 출력
- 연속된 수들의 곱의 최대값

```
방법 : 
누적합 처럼 진행하는데, 곱한 값과 현재 값을 비교해서 더 큰값을 남겨둔다.
누적하면서 최대값을 저장한다.
```



## 실전 문제 2 (회전 초밥(고))

- N : 회전 초밥 벨트에 놓은 접시의 수 2 <= N <= 3000000
- d : 초밥의 가짓 수 2 <= d <= 3000
- k : 연속해서 먹는 접시의 수 2 <= k <= 3000
- c : 쿠폰번호 1 <= c <= d

```
# 행사 정보
1. 원래 회전 초밥은 손님이 마음대로 초밥을 고르고, 먹은 초밥만큼 식대를 계산 BUT 벨트의 임의의 한 위치부터 K개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다.
2. 각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행
2-1. 1번 행사에 참여할 경우 이 쿠폰에 적힌 종류의 초밥 하나를 추가로 무료로 제공
2-2. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가 새로 만들어 손님에게 제공

문제 : 할인행사에 참여하여 가능한 다양한 종류의 초밥을 먹는다.
즉, 무조건 k개를 연속으로 먹어야함.
k개 연속 + 보너스 1개

EX)
k = 4
30번 초밥을 쿠폰으로 받음
쿠폰을 고려하지 않으면 4가지 다른 초밥을 먹을 수 있는 경우는 (9, 7, 30, 2) (30, 2, 7, 9) (2, 7, 9, 25) 세가지 경우
but 30번 초밥을 쿠폰으로 추가로 먹을 수 있기 때문에 (2, 7, 9, 25)를 고르면 5가지 종류의 초밥을 먹을 수 있음.

풀이 방법 :
A 배열에는 초밥이 순서대로 담겨 있다.
3000000 * 3000 -> 90억. 레일 하나에서 k개씩 끊어서 보는건 말이 안된다.
범위다 범위
범위로 가자
인덱스 하나 늘리고 반대쪽 줄이고

```













